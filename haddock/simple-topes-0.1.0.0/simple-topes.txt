-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/simple-topes#readme</a>
@package simple-topes
@version 0.1.0.0

module RSTT.Cube

-- | A label (constructor symbol).
newtype Label
Label :: String -> Label
[getLabel] :: Label -> String

-- | A variable.
newtype Var
Var :: String -> Var
[getVar] :: Var -> String

-- | A cube expression.
data Cube

-- | Unit cube: &lt;math&gt;.
CubeUnit :: Cube

-- | Product of cubes: &lt;math&gt;.
CubeProduct :: Cube -> Cube -> Cube

-- | A user-defined cube, e.g. &lt;math&gt;.
CubeCon :: Label -> Cube

-- | A cube variable: &lt;math&gt;.
CubeVar :: Var -> Cube

-- | A point in a cube.
data Point

-- | The only point in the unit cube: &lt;math&gt;.
PointUnit :: Point

-- | A pair of points: &lt;math&gt;.
PointPair :: Point -> Point -> Point

-- | First projection: &lt;math&gt;.
PointFirst :: Point -> Point

-- | Second projection: &lt;math&gt;.
PointSecond :: Point -> Point

-- | A user-defined point constructor, e.g. &lt;math&gt; or &lt;math&gt;.
PointCon :: Label -> [Point] -> Point

-- | A point variable: &lt;math&gt;.
PointVar :: Var -> Point

-- | A cube context consists of point variables with corresponding cubes.
type CubeContext = [(Var, Cube)]

-- | Pretty-print a <a>CubeContext</a>.
ppCubeContext :: CubeContext -> String

-- | Pretty-print a <a>Cube</a>.
ppCube :: Cube -> String

-- | Pretty-print a <a>Cube</a> expression in a given precedence
--   environment.
ppCubePrec :: Int -> Cube -> String

-- | Pretty-print a <a>Point</a>.
ppPoint :: Point -> String

-- | Pretty-print a <a>Point</a> expression in a given precedence
--   environment.
ppPointPrec :: Int -> Point -> String
instance Data.String.IsString RSTT.Cube.Label
instance GHC.Show.Show RSTT.Cube.Label
instance GHC.Classes.Eq RSTT.Cube.Label
instance Data.String.IsString RSTT.Cube.Var
instance GHC.Show.Show RSTT.Cube.Var
instance GHC.Classes.Eq RSTT.Cube.Var
instance GHC.Show.Show RSTT.Cube.Cube
instance GHC.Classes.Eq RSTT.Cube.Cube
instance GHC.Show.Show RSTT.Cube.Point
instance GHC.Classes.Eq RSTT.Cube.Point
instance Data.String.IsString RSTT.Cube.Point
instance Data.String.IsString RSTT.Cube.Cube


-- | The abstract syntax of language Syntax.
module RSTT.Syntax.Abs
data Program
Program :: [Decl] -> Program
data Decl
DeclCube :: Label -> [PointConDecl] -> Decl
DeclTopePrefix :: Label -> [Cube] -> [TopeRule] -> Decl
DeclShape :: Var -> Shape -> Decl
DeclCommandProve :: Sequent -> Decl
data Shape
Shape :: PointPattern -> Cube -> Tope -> Shape
data PointPattern
PointPatternVar :: Var -> PointPattern
PointPatternPair :: PointPattern -> PointPattern -> PointPattern
data PointConDecl
NullaryPointConDecl :: Label -> PointConDecl
PrefixPointConDecl :: Label -> [Cube] -> PointConDecl
data Cube
CubeProduct :: Cube -> Cube -> Cube
CubeUnit :: Cube
CubeCon :: Label -> Cube
CubeVar :: Var -> Cube
data TopeRule
TopeRule :: RuleName -> [Sequent] -> Line -> Sequent -> TopeRule
data RuleName
RuleName :: String -> RuleName
data Sequent
Sequent :: CubeContext -> TopeContext -> Tope -> Sequent
data CubeContext
CubeContextEmpty :: CubeContext
CubeContextNonEmpty :: [PointDecl] -> CubeContext
data PointDecl
PointDecl :: Var -> Cube -> PointDecl
data TopeContext
TopeContextEmpty :: TopeContext
TopeContextNonEmpty :: [Tope] -> TopeContext
data Tope
TopeTop :: Tope
TopeBottom :: Tope
TopeImplies :: Tope -> Tope -> Tope
TopeOr :: Tope -> Tope -> Tope
TopeAnd :: Tope -> Tope -> Tope
TopeEQ :: Point -> Point -> Tope
TopeCon :: Label -> [Point] -> Tope
TopeVar :: Var -> Tope
data Point
PointUnit :: Point
PointPair :: Point -> Point -> Point
PointFirst :: Point -> Point
PointSecond :: Point -> Point
PointCon :: Label -> [Point] -> Point
PointVar :: Var -> Point
nullaryPoint :: Label -> Point
newtype Label
Label :: String -> Label
newtype Var
Var :: String -> Var
newtype Line
Line :: String -> Line
instance GHC.Read.Read RSTT.Syntax.Abs.RuleName
instance GHC.Show.Show RSTT.Syntax.Abs.RuleName
instance GHC.Classes.Ord RSTT.Syntax.Abs.RuleName
instance GHC.Classes.Eq RSTT.Syntax.Abs.RuleName
instance Data.String.IsString RSTT.Syntax.Abs.Label
instance GHC.Read.Read RSTT.Syntax.Abs.Label
instance GHC.Show.Show RSTT.Syntax.Abs.Label
instance GHC.Classes.Ord RSTT.Syntax.Abs.Label
instance GHC.Classes.Eq RSTT.Syntax.Abs.Label
instance Data.String.IsString RSTT.Syntax.Abs.Var
instance GHC.Read.Read RSTT.Syntax.Abs.Var
instance GHC.Show.Show RSTT.Syntax.Abs.Var
instance GHC.Classes.Ord RSTT.Syntax.Abs.Var
instance GHC.Classes.Eq RSTT.Syntax.Abs.Var
instance GHC.Read.Read RSTT.Syntax.Abs.Point
instance GHC.Show.Show RSTT.Syntax.Abs.Point
instance GHC.Classes.Ord RSTT.Syntax.Abs.Point
instance GHC.Classes.Eq RSTT.Syntax.Abs.Point
instance GHC.Read.Read RSTT.Syntax.Abs.Tope
instance GHC.Show.Show RSTT.Syntax.Abs.Tope
instance GHC.Classes.Ord RSTT.Syntax.Abs.Tope
instance GHC.Classes.Eq RSTT.Syntax.Abs.Tope
instance GHC.Read.Read RSTT.Syntax.Abs.TopeContext
instance GHC.Show.Show RSTT.Syntax.Abs.TopeContext
instance GHC.Classes.Ord RSTT.Syntax.Abs.TopeContext
instance GHC.Classes.Eq RSTT.Syntax.Abs.TopeContext
instance GHC.Read.Read RSTT.Syntax.Abs.Cube
instance GHC.Show.Show RSTT.Syntax.Abs.Cube
instance GHC.Classes.Ord RSTT.Syntax.Abs.Cube
instance GHC.Classes.Eq RSTT.Syntax.Abs.Cube
instance GHC.Read.Read RSTT.Syntax.Abs.PointDecl
instance GHC.Show.Show RSTT.Syntax.Abs.PointDecl
instance GHC.Classes.Ord RSTT.Syntax.Abs.PointDecl
instance GHC.Classes.Eq RSTT.Syntax.Abs.PointDecl
instance GHC.Read.Read RSTT.Syntax.Abs.CubeContext
instance GHC.Show.Show RSTT.Syntax.Abs.CubeContext
instance GHC.Classes.Ord RSTT.Syntax.Abs.CubeContext
instance GHC.Classes.Eq RSTT.Syntax.Abs.CubeContext
instance GHC.Read.Read RSTT.Syntax.Abs.Sequent
instance GHC.Show.Show RSTT.Syntax.Abs.Sequent
instance GHC.Classes.Ord RSTT.Syntax.Abs.Sequent
instance GHC.Classes.Eq RSTT.Syntax.Abs.Sequent
instance GHC.Read.Read RSTT.Syntax.Abs.PointConDecl
instance GHC.Show.Show RSTT.Syntax.Abs.PointConDecl
instance GHC.Classes.Ord RSTT.Syntax.Abs.PointConDecl
instance GHC.Classes.Eq RSTT.Syntax.Abs.PointConDecl
instance GHC.Read.Read RSTT.Syntax.Abs.PointPattern
instance GHC.Show.Show RSTT.Syntax.Abs.PointPattern
instance GHC.Classes.Ord RSTT.Syntax.Abs.PointPattern
instance GHC.Classes.Eq RSTT.Syntax.Abs.PointPattern
instance GHC.Read.Read RSTT.Syntax.Abs.Shape
instance GHC.Show.Show RSTT.Syntax.Abs.Shape
instance GHC.Classes.Ord RSTT.Syntax.Abs.Shape
instance GHC.Classes.Eq RSTT.Syntax.Abs.Shape
instance Data.String.IsString RSTT.Syntax.Abs.Line
instance GHC.Read.Read RSTT.Syntax.Abs.Line
instance GHC.Show.Show RSTT.Syntax.Abs.Line
instance GHC.Classes.Ord RSTT.Syntax.Abs.Line
instance GHC.Classes.Eq RSTT.Syntax.Abs.Line
instance GHC.Read.Read RSTT.Syntax.Abs.TopeRule
instance GHC.Show.Show RSTT.Syntax.Abs.TopeRule
instance GHC.Classes.Ord RSTT.Syntax.Abs.TopeRule
instance GHC.Classes.Eq RSTT.Syntax.Abs.TopeRule
instance GHC.Read.Read RSTT.Syntax.Abs.Decl
instance GHC.Show.Show RSTT.Syntax.Abs.Decl
instance GHC.Classes.Ord RSTT.Syntax.Abs.Decl
instance GHC.Classes.Eq RSTT.Syntax.Abs.Decl
instance GHC.Read.Read RSTT.Syntax.Abs.Program
instance GHC.Show.Show RSTT.Syntax.Abs.Program
instance GHC.Classes.Ord RSTT.Syntax.Abs.Program
instance GHC.Classes.Eq RSTT.Syntax.Abs.Program


-- | BNF Converter: Error Monad.
--   
--   Module for backwards compatibility.
--   
--   The generated parser now uses <tt><a>Either</a> String</tt> as error
--   monad. This module defines a type synonym <a>Err</a> and pattern
--   synonyms <a>Bad</a> and <a>Ok</a> for <a>Left</a> and <a>Right</a>.
module RSTT.Syntax.ErrM

-- | Error monad with <a>String</a> error messages.
type Err = Either String
pattern Bad :: a -> Either a b
pattern Ok :: forall {a} {b}. b -> Either a b
instance Control.Monad.Fail.MonadFail RSTT.Syntax.ErrM.Err
instance GHC.Base.Alternative RSTT.Syntax.ErrM.Err
instance GHC.Base.MonadPlus RSTT.Syntax.ErrM.Err

module RSTT.Syntax.Lex
alex_tab_size :: Int
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc user)
alex_actions :: Array Int (Posn -> String -> Token)
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Any :: Type)) -> Int -> AlexAcc (Any :: Type)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: AlexInput -> Int -> AlexReturn (Posn -> String -> Token)
alexScanUser :: t -> AlexInput -> Int -> AlexReturn (Posn -> String -> Token)
alex_scan_tkn :: t -> t -> Int# -> AlexInput -> Int# -> AlexLastAcc -> (AlexLastAcc, AlexInput)
data AlexLastAcc
AlexNone :: AlexLastAcc
AlexLastAcc :: !Int -> !AlexInput -> !Int -> AlexLastAcc
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc
data AlexAcc user
AlexAccNone :: AlexAcc user
AlexAcc :: Int -> AlexAcc user
AlexAccSkip :: AlexAcc user

-- | Create a token with position.
tok :: (String -> Tok) -> Posn -> String -> Token

-- | Token without position.
data Tok

-- | Reserved word or symbol.
TK :: {-# UNPACK #-} !TokSymbol -> Tok

-- | String literal.
TL :: !String -> Tok

-- | Integer literal.
TI :: !String -> Tok

-- | Identifier.
TV :: !String -> Tok

-- | Float literal.
TD :: !String -> Tok

-- | Character literal.
TC :: !String -> Tok
T_Label :: !String -> Tok
T_Var :: !String -> Tok
T_Line :: !String -> Tok

-- | Smart constructor for <a>Tok</a> for the sake of backwards
--   compatibility.
pattern TS :: String -> Int -> Tok

-- | Keyword or symbol tokens have a unique ID.
data TokSymbol
TokSymbol :: String -> !Int -> TokSymbol

-- | Keyword or symbol text.
[tsText] :: TokSymbol -> String

-- | Unique ID.
[tsID] :: TokSymbol -> !Int

-- | Token with position.
data Token
PT :: Posn -> Tok -> Token
Err :: Posn -> Token

-- | Pretty print a position.
printPosn :: Posn -> String

-- | Pretty print the position of the first token in the list.
tokenPos :: [Token] -> String

-- | Get the position of a token.
tokenPosn :: Token -> Posn

-- | Get line and column of a token.
tokenLineCol :: Token -> (Int, Int)

-- | Get line and column of a position.
posLineCol :: Posn -> (Int, Int)

-- | Convert a token into "position token" form.
mkPosToken :: Token -> ((Int, Int), String)

-- | Convert a token to its text.
tokenText :: Token -> String

-- | Convert a token to a string.
prToken :: Token -> String

-- | Finite map from text to token organized as binary search tree.
data BTree

-- | Nil (leaf).
N :: BTree

-- | Binary node.
B :: String -> Tok -> BTree -> BTree -> BTree

-- | Convert potential keyword into token or use fallback conversion.
eitherResIdent :: (String -> Tok) -> String -> Tok

-- | The keywords and symbols of the language organized as binary search
--   tree.
resWords :: BTree

-- | Unquote string literal.
unescapeInitTail :: String -> String
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
alexStartPos :: Posn
alexMove :: Posn -> Char -> Posn
type Byte = Word8
type AlexInput = (Posn, Char, [Byte], String)
tokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alexInputPrevChar :: AlexInput -> Char

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
alex_action_3 :: Posn -> String -> Token
alex_action_4 :: Posn -> String -> Token
alex_action_5 :: Posn -> String -> Token
alex_action_6 :: Posn -> String -> Token
alex_action_7 :: Posn -> String -> Token
alex_action_8 :: Posn -> String -> Token
instance GHC.Show.Show RSTT.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord RSTT.Syntax.Lex.Tok
instance GHC.Show.Show RSTT.Syntax.Lex.Tok
instance GHC.Classes.Eq RSTT.Syntax.Lex.Tok
instance GHC.Show.Show RSTT.Syntax.Lex.BTree
instance GHC.Classes.Ord RSTT.Syntax.Lex.Posn
instance GHC.Show.Show RSTT.Syntax.Lex.Posn
instance GHC.Classes.Eq RSTT.Syntax.Lex.Posn
instance GHC.Classes.Ord RSTT.Syntax.Lex.Token
instance GHC.Show.Show RSTT.Syntax.Lex.Token
instance GHC.Classes.Eq RSTT.Syntax.Lex.Token
instance GHC.Classes.Eq RSTT.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord RSTT.Syntax.Lex.TokSymbol

module RSTT.Syntax.Layout
data LayoutDelimiters
LayoutDelimiters :: TokSymbol -> Maybe TokSymbol -> Maybe TokSymbol -> LayoutDelimiters
[delimSep] :: LayoutDelimiters -> TokSymbol

-- | Nothing for toplevel layout.
[delimOpen] :: LayoutDelimiters -> Maybe TokSymbol

-- | Nothing for toplevel layout.
[delimClose] :: LayoutDelimiters -> Maybe TokSymbol
layoutWords :: [(TokSymbol, LayoutDelimiters)]
layoutStopWords :: [TokSymbol]
layoutOpen :: [TokSymbol]
layoutClose :: [TokSymbol]
layoutSep :: [TokSymbol]
parenOpen :: [TokSymbol]
parenClose :: [TokSymbol]

-- | Report an error during layout resolution.
layoutError :: [Token] -> String -> a

-- | Replace layout syntax with explicit layout tokens.
resolveLayout :: Bool -> [Token] -> [Token]
type Position = Posn
type Line = Int
type Column = Int

-- | Entry of the layout stack.
data Block

-- | An implicit layout block with its start column.
Implicit :: LayoutDelimiters -> Status -> Column -> Block
Explicit :: Block

-- | Get current indentation. 0 if we are in an explicit block.
indentation :: Block -> Column

-- | Check if s block is implicit.
isImplicit :: Block -> Bool
data Status

-- | A layout column that has not been confirmed by a line break
Tentative :: Status

-- | A layout column that has been confirmed by a line break.
Definitive :: Status

-- | Add a new implicit layout block.
addImplicit :: LayoutDelimiters -> Position -> Position -> [Block] -> [Block]

-- | Confirm tentative blocks that are not more indented than <tt>col</tt>.
confirm :: Column -> [Block] -> [Block]

-- | Get the position immediately to the right of the given token. If no
--   token is given, gets the first position in the file.
afterPrev :: Maybe Token -> Position

-- | Get the position immediately to the right of the given token.
nextPos :: Token -> Position

-- | Get the number of characters in the token.
tokenLength :: Token -> Int

-- | Create a position symbol token.
sToken :: Position -> TokSymbol -> Token

-- | Get the line number of a token.
line :: Token -> Line

-- | Get the column number of a token.
column :: Token -> Column

-- | Is the following token on a new line?
newLine :: Maybe Token -> Token -> Bool

-- | Check if a word is a layout start token.
isLayout :: Token -> Maybe LayoutDelimiters

-- | Check if a token is one of the given symbols.
isTokenIn :: [TokSymbol] -> Token -> Bool

-- | Check if a token is a layout stop token.
isStop :: Token -> Bool

-- | Check if a token is the layout open token.
isLayoutOpen :: Token -> Bool

-- | Check if a token is the layout separator token.
isLayoutSep :: Token -> Bool

-- | Check if a token is the layout close token.
isLayoutClose :: Token -> Bool

-- | Check if a token is an opening parenthesis.
isParenOpen :: Token -> Bool

-- | Check if a token is a closing parenthesis.
isParenClose :: Token -> Bool

module RSTT.Syntax.Par
happyError :: [Token] -> Err a
myLexer :: String -> [Token]
pProgram :: [Token] -> Err Program
pDecl :: [Token] -> Err Decl
pListDecl :: [Token] -> Err [Decl]
pShape :: [Token] -> Err Shape
pPointPattern :: [Token] -> Err PointPattern
pPointConDecl :: [Token] -> Err PointConDecl
pListPointConDecl :: [Token] -> Err [PointConDecl]
pCube :: [Token] -> Err Cube
pCube1 :: [Token] -> Err Cube
pListCube :: [Token] -> Err [Cube]
pTopeRule :: [Token] -> Err TopeRule
pListTopeRule :: [Token] -> Err [TopeRule]
pRuleName :: [Token] -> Err RuleName
pSequent :: [Token] -> Err Sequent
pListSequent :: [Token] -> Err [Sequent]
pCubeContext :: [Token] -> Err CubeContext
pPointDecl :: [Token] -> Err PointDecl
pListPointDecl :: [Token] -> Err [PointDecl]
pTopeContext :: [Token] -> Err TopeContext
pTope :: [Token] -> Err Tope
pTope1 :: [Token] -> Err Tope
pTope2 :: [Token] -> Err Tope
pTope3 :: [Token] -> Err Tope
pListTope :: [Token] -> Err [Tope]
pPoint :: [Token] -> Err Point
pListPoint :: [Token] -> Err [Point]


-- | Pretty-printer for RSTT.
module RSTT.Syntax.Print

-- | The top-level printing method.
printTree :: Print a => a -> String
type Doc = [ShowS] -> [ShowS]
doc :: ShowS -> Doc
render :: Doc -> String
parenth :: Doc -> Doc
concatS :: [ShowS] -> ShowS
concatD :: [Doc] -> Doc
replicateS :: Int -> ShowS -> ShowS

-- | The printer class does the job.
class Print a
prt :: Print a => Int -> a -> Doc
printString :: String -> Doc
mkEsc :: Char -> Char -> ShowS
prPrec :: Int -> Int -> Doc -> Doc
instance RSTT.Syntax.Print.Print a => RSTT.Syntax.Print.Print [a]
instance RSTT.Syntax.Print.Print GHC.Types.Char
instance RSTT.Syntax.Print.Print GHC.Base.String
instance RSTT.Syntax.Print.Print GHC.Num.Integer.Integer
instance RSTT.Syntax.Print.Print GHC.Types.Double
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Label
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Var
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Line
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Program
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Decl
instance RSTT.Syntax.Print.Print [RSTT.Syntax.Abs.Decl]
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Shape
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.PointPattern
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.PointConDecl
instance RSTT.Syntax.Print.Print [RSTT.Syntax.Abs.PointConDecl]
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Cube
instance RSTT.Syntax.Print.Print [RSTT.Syntax.Abs.Cube]
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.TopeRule
instance RSTT.Syntax.Print.Print [RSTT.Syntax.Abs.TopeRule]
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.RuleName
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Sequent
instance RSTT.Syntax.Print.Print [RSTT.Syntax.Abs.Sequent]
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.CubeContext
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.PointDecl
instance RSTT.Syntax.Print.Print [RSTT.Syntax.Abs.PointDecl]
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.TopeContext
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Tope
instance RSTT.Syntax.Print.Print [RSTT.Syntax.Abs.Tope]
instance RSTT.Syntax.Print.Print RSTT.Syntax.Abs.Point
instance RSTT.Syntax.Print.Print [RSTT.Syntax.Abs.Point]

module RSTT.Syntax.Skel
type Err = Either String
type Result = Err String
failure :: Show a => a -> Result
transLabel :: Label -> Result
transVar :: Var -> Result
transLine :: Line -> Result
transProgram :: Program -> Result
transDecl :: Decl -> Result
transShape :: Shape -> Result
transPointPattern :: PointPattern -> Result
transPointConDecl :: PointConDecl -> Result
transCube :: Cube -> Result
transTopeRule :: TopeRule -> Result
transRuleName :: RuleName -> Result
transSequent :: Sequent -> Result
transCubeContext :: CubeContext -> Result
transPointDecl :: PointDecl -> Result
transTopeContext :: TopeContext -> Result
transTope :: Tope -> Result
transPoint :: Point -> Result

module RSTT.Tope

-- | A tope expression.
data Tope

-- | Top tope: &lt;math&gt;.
TopeTop :: Tope

-- | Bottom tope: &lt;math&gt;.
TopeBottom :: Tope

-- | AND tope: &lt;math&gt;.
TopeAnd :: Tope -> Tope -> Tope

-- | OR tope: &lt;math&gt;.
TopeOr :: Tope -> Tope -> Tope

-- | Point equality tope: &lt;math&gt;.
TopeEQ :: Point -> Point -> Tope

-- | A tope variable.
TopeVar :: Var -> Tope

-- | IMPLIES tope: &lt;math&gt;. NOTE: this tope is added to internalise
--   known tope judgements and simplify proof search.
TopeImplies :: Tope -> Tope -> Tope

-- | User-defined tope constructor (fully applied to some points).
TopeCon :: Label -> [Point] -> Tope

-- | A shape is a tope in a cube context (with just one cube point
--   variable): &lt;math&gt;.
data Shape
Shape :: (Var, Cube) -> Tope -> Shape
[shapePoint] :: Shape -> (Var, Cube)
[shapeTope] :: Shape -> Tope

-- | A tope context consists of a set of topes.
type TopeContext = [Tope]

-- | Pretty-print a <a>TopeContext</a>.
ppTopeContext :: TopeContext -> String

-- | Pretty-print a <a>Shape</a>.
ppShape :: Shape -> String

-- | Pretty-print a <a>Tope</a>.
ppTope :: Tope -> String

-- | Pretty-print a <a>Tope</a> expression in a given precedence
--   environment.
ppTopePrec :: Int -> Tope -> String
instance GHC.Show.Show RSTT.Tope.Tope
instance GHC.Classes.Eq RSTT.Tope.Tope
instance GHC.Show.Show RSTT.Tope.Shape
instance GHC.Classes.Eq RSTT.Tope.Shape
instance Data.String.IsString RSTT.Tope.Tope

module RSTT.Tope.Proof

-- | Tope sequent &lt;math&gt;.
data Sequent
Sequent :: CubeContext -> TopeContext -> Tope -> Sequent

-- | Cube context &lt;math&gt;.
[sequentCubeContext] :: Sequent -> CubeContext

-- | Tope context &lt;math&gt;.
[sequentTopeContext] :: Sequent -> TopeContext

-- | A tope &lt;math&gt; on the right hand side.
[sequentTope] :: Sequent -> Tope

-- | Pretty-print a <a>Sequent</a>.
--   
--   <pre>
--   &gt;&gt;&gt; points = [("t", "I"), ("s", "J")]
--   
--   &gt;&gt;&gt; topes = [("φ" `TopeOr` "ζ") `TopeAnd` ("ψ" `TopeOr` "χ"), ("t" `TopeEQ` "s")]
--   
--   &gt;&gt;&gt; putStrLn (ppSequent (Sequent points topes ("s" `TopeEQ` "t")))
--   t : I, s : J | (φ ∨ ζ) ∧ (ψ ∨ χ), t ≡ s ⊢ s ≡ t
--   </pre>
ppSequent :: Sequent -> String

-- | A name of a (tope inference) rule.
type RuleName = String

-- | A collection of tope inference rules. Intuitively,
--   <tt><a>Rules</a></tt> is a non-deterministic function from
--   <a>Sequent</a> to <tt>(<a>RuleName</a>, [<a>Sequent</a>])</tt>.
type Rules = RulesM (RuleName, [Sequent])

-- | A collection of generalized tope inference rules. Intuitively,
--   <tt><a>RulesM</a> a</tt> is a non-deterministic function from
--   <a>Sequent</a> to <tt>a</tt>.
newtype RulesM a
RulesM :: ReaderT Sequent Logic a -> RulesM a
[applyRulesM] :: RulesM a -> ReaderT Sequent Logic a

-- | Rules for intuitionistic tope logic:
--   
--   <ul>
--   <li><a>axiom</a> rule</li>
--   <li>&lt;math&gt;-rules (<a>leftAnd</a> and <a>rightAnd</a>)</li>
--   <li>&lt;math&gt;-rules (<a>leftOr</a>, <a>rightOrL</a>, and
--   <a>rightOrR</a>)</li>
--   <li>&lt;math&gt;-rules (<a>leftImplies</a>, <a>rightImplies</a>)</li>
--   </ul>
rulesLJ :: Rules

-- | Rules for tope equality:
--   
--   <ul>
--   <li>reflexivity (<a>reflEQ</a>)</li>
--   <li>symmetry (<a>symEQ</a>)</li>
--   <li>transitivity (<a>transEQ</a>)</li>
--   </ul>
rulesEQ :: Rules

-- | Rules for intuitionistic tope logic with equality:
--   
--   <ul>
--   <li>intuitionistic rules <a>rulesLJ</a></li>
--   <li>equality tope rules <a>rulesEQ</a></li>
--   </ul>
rulesLJE :: Rules

-- | Rules for inequality tope (not built-in).
--   
--   <ul>
--   <li>reflexivity (<a>reflLEQ</a>)</li>
--   <li>antisymmetry (<a>antisymLEQ</a>)</li>
--   <li>transitivity (<a>transLEQ</a>)</li>
--   <li>excluded middle (<a>lemLEQ</a>)</li>
--   <li>infimum (<a>zeroLEQ</a>)</li>
--   <li>supremum (<a>oneLEQ</a>)</li>
--   <li>distinctness of 0 and 1 (<a>distinctLEQ</a>)</li>
--   </ul>
rulesLEQ :: Rules
ruleTop :: Rules
ruleBottom :: Rules
leftAnd :: Rules
leftOr :: Rules
leftImplies :: Rules
rightImplies :: Rules
rightAnd :: Rules
rightOrL :: Rules
rightOrR :: Rules
axiom :: Rules

-- | Transitivity rule for equality tope (see <a>TopeEQ</a>).
--   
--   <pre>
--   ———————————
--    ⋅ ⊢ x ≡ x
--   </pre>
reflEQ :: Rules

-- | Transitivity rule for equality tope (see <a>TopeEQ</a>).
--   
--   <pre>
--        x ≡ y, y ≡ z ⊢ φ
--   —————————————————————————
--    x ≡ y, y ≡ z, x ≡ z ⊢ φ
--   </pre>
transEQ :: Rules

-- | Symmetry rule for equality tope (see <a>TopeEQ</a>).
--   
--   <pre>
--       x ≡ y ⊢ φ
--   ——————————————————
--    x ≡ y, y ≡ x ⊢ φ
--   </pre>
symEQ :: Rules
reflLEQ :: Rules
transLEQ :: Rules
antisymLEQ :: Rules
lemLEQ :: Rules
zeroLEQ :: Rules
oneLEQ :: Rules
distinctLEQ :: Rules

-- | Nondeterministically select exactly &lt;math&gt; elements from a given
--   list, also returning the remaining part of the list.
selectN :: Alternative f => Int -> [a] -> f ([a], [a])

-- | Nondeterministically select exactly one element from a given list,
--   also returning the remaining part of the list.
selectOne :: (Alternative f, MonadFail f) => [a] -> f (a, [a])

-- | Nondeterministically select exactly one element from a given list.
choose :: Alternative f => [a] -> f a

-- | A complete proof is a proof tree without any unfinished parts.
type Proof = ProofTree Void

-- | A proof tree parametrized by the type of leaves (unfinished proofs).
data ProofTree a

-- | A leaf represents an unfinished part of a proof.
Leaf :: a -> ProofTree a

-- | A node in a proof tree corresponds to a single rule application.
Node :: Sequent -> RuleName -> [ProofTree a] -> ProofTree a

-- | Convert a proof tree into a complete proof if possible.
close :: Alternative f => ProofTree a -> f Proof

-- | Pretty print a proof tree (in ASCII form).
ppProof :: Proof -> String

-- | Extract proof nodes with corresponding depths.
proofNodesWithDepth :: Proof -> [(Int, String)]

-- | Pretty-print depth-annotated nodes as a ASCII tree-like structure.
--   
--   <pre>
--   &gt;&gt;&gt; putStr $ ppNodesWithDepth (zip [0,1,2,1,2,3,3,2,3] (map show [0..]))
--   0
--   ├─ 1
--   │  └─ 2
--   └─ 3
--      ├─ 4
--      │  ├─ 5
--      │  └─ 6
--      └─ 7
--         └─ 8
--   </pre>
ppNodesWithDepth :: [(Int, String)] -> String

-- | Pretty-print an ASCII tree-like structure based on depth list.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ putStrLn $ depthsTree [0,1,2,1,2,3,3,2,3]
--   └─
--      ├─
--      │  └─
--      └─
--         ├─
--         │  ├─
--         │  └─
--         └─
--            └─
--   </pre>
depthsTree :: [Int] -> [String]

-- | A simple DFS proof search algorithm for a given set of rules.
proveWithDFS :: Int -> Rules -> Sequent -> Logic (ProofTree Sequent)

-- | A simple k-depth proof search algorithm for a given set of rules.
proveWithBFSviaDFS :: Int -> Int -> Rules -> Sequent -> Logic Proof

-- | Search for a proof using simple DFS algorithm (see
--   <a>proveWithDFS</a>).
proveWithDFS' :: Int -> Rules -> Sequent -> Maybe Proof

-- | Search for a proof using a combination of BFS and DFS algorithms (see
--   <tt>proveWithBFS</tt>).
proveWithBFSviaDFS' :: Int -> Int -> Rules -> Sequent -> Maybe Proof

-- | Search for a proof using BFS and print proof tree (see
--   <a>ppProof</a>).
proveAndPrintBFS :: Int -> Rules -> Sequent -> IO ()

-- | Search for a proof using a combination of BFS and DFS and print proof
--   tree (see <a>ppProof</a>).
proveAndPrintBFSviaDFS :: Int -> Int -> Rules -> Sequent -> IO ()

-- | Search for a proof using DFS and print proof tree (see
--   <a>ppProof</a>).
proveAndPrintDFS :: Int -> Rules -> Sequent -> IO ()

-- | <pre>
--   &gt;&gt;&gt; putStrLn (ppSequent ex1)
--   ⋅ | (φ ∨ ζ) ∧ (ψ ∨ χ) ⊢ φ ∧ ψ ∨ ζ ∧ ψ ∨ χ
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; proveAndPrintBFS 8 rulesLJ ex1
--   [∧L]  ⋅ | (φ ∨ ζ) ∧ (ψ ∨ χ) ⊢ φ ∧ ψ ∨ ζ ∧ ψ ∨ χ
--   └─ [∨L]  ⋅ | φ ∨ ζ, ψ ∨ χ ⊢ φ ∧ ψ ∨ ζ ∧ ψ ∨ χ
--      ├─ [∨L]  ⋅ | φ, ψ ∨ χ ⊢ φ ∧ ψ ∨ ζ ∧ ψ ∨ χ
--      │  ├─ [∨R₁]  ⋅ | ψ, φ ⊢ φ ∧ ψ ∨ ζ ∧ ψ ∨ χ
--      │  │  └─ [∧R]  ⋅ | ψ, φ ⊢ φ ∧ ψ
--      │  │     ├─ [Ax]  ⋅ | ψ, φ ⊢ φ
--      │  │     └─ [Ax]  ⋅ | ψ, φ ⊢ ψ
--      │  └─ [∨R₂]  ⋅ | χ, φ ⊢ φ ∧ ψ ∨ ζ ∧ ψ ∨ χ
--      │     └─ [∨R₂]  ⋅ | χ, φ ⊢ ζ ∧ ψ ∨ χ
--      │        └─ [Ax]  ⋅ | χ, φ ⊢ χ
--      └─ [∨L]  ⋅ | ζ, ψ ∨ χ ⊢ φ ∧ ψ ∨ ζ ∧ ψ ∨ χ
--         ├─ [∨R₂]  ⋅ | ψ, ζ ⊢ φ ∧ ψ ∨ ζ ∧ ψ ∨ χ
--         │  └─ [∨R₁]  ⋅ | ψ, ζ ⊢ ζ ∧ ψ ∨ χ
--         │     └─ [∧R]  ⋅ | ψ, ζ ⊢ ζ ∧ ψ
--         │        ├─ [Ax]  ⋅ | ψ, ζ ⊢ ζ
--         │        └─ [Ax]  ⋅ | ψ, ζ ⊢ ψ
--         └─ [∨R₂]  ⋅ | χ, ζ ⊢ φ ∧ ψ ∨ ζ ∧ ψ ∨ χ
--            └─ [∨R₂]  ⋅ | χ, ζ ⊢ ζ ∧ ψ ∨ χ
--               └─ [Ax]  ⋅ | χ, ζ ⊢ χ
--   </pre>
ex1 :: Sequent

-- | <pre>
--   &gt;&gt;&gt; putStrLn (ppSequent ex2)
--   ⋅ | φ ∧ ψ ∨ ζ ∧ χ ⊢ (φ ∨ ζ) ∧ (ψ ∨ χ)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; proveAndPrintBFS 8 rulesLJ ex2
--   [∧R]  ⋅ | φ ∧ ψ ∨ ζ ∧ χ ⊢ (φ ∨ ζ) ∧ (ψ ∨ χ)
--   ├─ [∨L]  ⋅ | φ ∧ ψ ∨ ζ ∧ χ ⊢ φ ∨ ζ
--   │  ├─ [∧L]  ⋅ | φ ∧ ψ ⊢ φ ∨ ζ
--   │  │  └─ [∨R₁]  ⋅ | φ, ψ ⊢ φ ∨ ζ
--   │  │     └─ [Ax]  ⋅ | φ, ψ ⊢ φ
--   │  └─ [∧L]  ⋅ | ζ ∧ χ ⊢ φ ∨ ζ
--   │     └─ [∨R₂]  ⋅ | ζ, χ ⊢ φ ∨ ζ
--   │        └─ [Ax]  ⋅ | ζ, χ ⊢ ζ
--   └─ [∨L]  ⋅ | φ ∧ ψ ∨ ζ ∧ χ ⊢ ψ ∨ χ
--      ├─ [∧L]  ⋅ | φ ∧ ψ ⊢ ψ ∨ χ
--      │  └─ [∨R₁]  ⋅ | φ, ψ ⊢ ψ ∨ χ
--      │     └─ [Ax]  ⋅ | φ, ψ ⊢ ψ
--      └─ [∧L]  ⋅ | ζ ∧ χ ⊢ ψ ∨ χ
--         └─ [∨R₂]  ⋅ | ζ, χ ⊢ ψ ∨ χ
--            └─ [Ax]  ⋅ | ζ, χ ⊢ χ
--   </pre>
ex2 :: Sequent

-- | <pre>
--   &gt;&gt;&gt; putStrLn (ppSequent ex3)
--   ⋅ | x ≡ y ∧ y ≡ z ⊢ z ≡ x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; proveAndPrintBFS 35 (rulesLJE &lt;&gt; rulesLEQ) ex3
--   [∧L]  ⋅ | x ≡ y ∧ y ≡ z ⊢ z ≡ x
--   └─ [≡L(trans)]  ⋅ | x ≡ y, y ≡ z ⊢ z ≡ x
--      └─ [≡L(sym)]  ⋅ | x ≡ z, x ≡ y, y ≡ z ⊢ z ≡ x
--         └─ [Ax]  ⋅ | z ≡ x, x ≡ z, x ≡ y, y ≡ z ⊢ z ≡ x
--   </pre>
ex3 :: Sequent

-- | <pre>
--   &gt;&gt;&gt; putStrLn (ppSequent ex4)
--   ⋅ | (t ≡ s ∨ t ≡ u) ∧ s ≡ u ⊢ t ≡ s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; proveAndPrintBFS 8 rulesLJE ex4
--   [∧L]  ⋅ | (t ≡ s ∨ t ≡ u) ∧ s ≡ u ⊢ t ≡ s
--   └─ [∨L]  ⋅ | t ≡ s ∨ t ≡ u, s ≡ u ⊢ t ≡ s
--      ├─ [Ax]  ⋅ | t ≡ s, s ≡ u ⊢ t ≡ s
--      └─ [≡L(sym)]  ⋅ | t ≡ u, s ≡ u ⊢ t ≡ s
--         └─ [≡L(trans)]  ⋅ | u ≡ s, t ≡ u, s ≡ u ⊢ t ≡ s
--            └─ [Ax]  ⋅ | t ≡ s, u ≡ s, t ≡ u, s ≡ u ⊢ t ≡ s
--   </pre>
ex4 :: Sequent

-- | <pre>
--   &gt;&gt;&gt; putStrLn (ppSequent ex5)
--   ⋅ | (≤(t, s) ∨ ≤(s, u)) ∧ ≤(t, u) ⊢ ≤(t, u) ∨ ≤(s, t) ∨ ≤(u, s)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; proveAndPrintBFS 5 (rulesLJE &lt;&gt; rulesLEQ) ex5
--   [∧L]  ⋅ | (≤(t, s) ∨ ≤(s, u)) ∧ ≤(t, u) ⊢ ≤(t, u) ∨ ≤(s, t) ∨ ≤(u, s)
--   └─ [∨R₁]  ⋅ | ≤(t, s) ∨ ≤(s, u), ≤(t, u) ⊢ ≤(t, u) ∨ ≤(s, t) ∨ ≤(u, s)
--      └─ [∨R₁]  ⋅ | ≤(t, s) ∨ ≤(s, u), ≤(t, u) ⊢ ≤(t, u) ∨ ≤(s, t)
--         └─ [Ax]  ⋅ | ≤(t, s) ∨ ≤(s, u), ≤(t, u) ⊢ ≤(t, u)
--   </pre>
ex5 :: Sequent
instance GHC.Show.Show RSTT.Tope.Proof.Sequent
instance GHC.Classes.Eq RSTT.Tope.Proof.Sequent
instance Control.Monad.Logic.Class.MonadLogic RSTT.Tope.Proof.RulesM
instance Control.Monad.Reader.Class.MonadReader RSTT.Tope.Proof.Sequent RSTT.Tope.Proof.RulesM
instance Control.Monad.Fail.MonadFail RSTT.Tope.Proof.RulesM
instance GHC.Base.MonadPlus RSTT.Tope.Proof.RulesM
instance GHC.Base.Alternative RSTT.Tope.Proof.RulesM
instance GHC.Base.Monad RSTT.Tope.Proof.RulesM
instance GHC.Base.Applicative RSTT.Tope.Proof.RulesM
instance GHC.Base.Functor RSTT.Tope.Proof.RulesM
instance Data.Traversable.Traversable RSTT.Tope.Proof.ProofTree
instance Data.Foldable.Foldable RSTT.Tope.Proof.ProofTree
instance GHC.Base.Functor RSTT.Tope.Proof.ProofTree
instance GHC.Show.Show a => GHC.Show.Show (RSTT.Tope.Proof.ProofTree a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (RSTT.Tope.Proof.ProofTree a)
instance GHC.Base.Applicative RSTT.Tope.Proof.ProofTree
instance GHC.Base.Monad RSTT.Tope.Proof.ProofTree
instance GHC.Base.Semigroup (RSTT.Tope.Proof.RulesM a)
instance GHC.Base.Monoid (RSTT.Tope.Proof.RulesM a)

module RSTT.Interpret
interpretIO :: String -> IO ()
interpretProgramIO :: Program -> IO ()
interpret :: String -> Either String [String]
interpretProgram :: Program -> [String]
interpretDecl :: Decl -> StateT Rules (Writer [String]) ()
convertRule :: TopeRule -> Rules
data Substs
Substs :: [(Var, Cube)] -> [(Var, Point)] -> [(Var, Tope)] -> Substs
[substCubeVars] :: Substs -> [(Var, Cube)]
[substPointVars] :: Substs -> [(Var, Point)]
[substTopeVars] :: Substs -> [(Var, Tope)]
matchSequent :: (MonadPlus f, MonadFail f) => Sequent -> Sequent -> f Substs
matchTope :: MonadPlus f => Tope -> Tope -> f Substs
matchPoint :: MonadPlus f => Point -> Point -> f Substs
matchTopes :: (MonadPlus f, MonadFail f) => Substs -> [Tope] -> [Tope] -> f Substs
mergeSubsts :: MonadPlus f => Substs -> Substs -> f Substs
mergeManySubsts :: MonadPlus f => [Substs] -> f Substs
merge :: (MonadPlus f, Eq k, Eq v, Show k, Show v) => [(k, v)] -> [(k, v)] -> f [(k, v)]
normalizeSequent :: Sequent -> Sequent
applySubsts :: Substs -> Sequent -> Sequent
substInCubeContext :: [(Var, Cube)] -> CubeContext -> CubeContext
substInTopeContext :: [(Var, Point)] -> [(Var, Tope)] -> TopeContext -> TopeContext
substInTope :: [(Var, Point)] -> [(Var, Tope)] -> Tope -> Tope
substInPoint :: [(Var, Point)] -> Point -> Point
convertSequent :: Sequent -> Sequent
convertCubeContext :: CubeContext -> CubeContext
convertCube :: Cube -> Cube
convertPoint :: Point -> Point
convertTope :: Tope -> Tope
convertTopeContext :: TopeContext -> TopeContext
